// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/xichen2020/eventdb/generated/proto/servicepb/query.proto

package servicepb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TimeUnit int32

const (
	TimeUnit_UNKNOWNUNIT TimeUnit = 0
	TimeUnit_SECOND      TimeUnit = 1
	TimeUnit_MILLISECOND TimeUnit = 2
	TimeUnit_MICROSECOND TimeUnit = 3
	TimeUnit_NANOSECOND  TimeUnit = 4
	TimeUnit_MINUTE      TimeUnit = 5
	TimeUnit_HOUR        TimeUnit = 6
	TimeUnit_DAY         TimeUnit = 7
	TimeUnit_YEAR        TimeUnit = 8
)

var TimeUnit_name = map[int32]string{
	0: "UNKNOWNUNIT",
	1: "SECOND",
	2: "MILLISECOND",
	3: "MICROSECOND",
	4: "NANOSECOND",
	5: "MINUTE",
	6: "HOUR",
	7: "DAY",
	8: "YEAR",
}
var TimeUnit_value = map[string]int32{
	"UNKNOWNUNIT": 0,
	"SECOND":      1,
	"MILLISECOND": 2,
	"MICROSECOND": 3,
	"NANOSECOND":  4,
	"MINUTE":      5,
	"HOUR":        6,
	"DAY":         7,
	"YEAR":        8,
}

func (x TimeUnit) String() string {
	return proto.EnumName(TimeUnit_name, int32(x))
}
func (TimeUnit) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuery, []int{0} }

type FilterCombinator int32

const (
	FilterCombinator_UNKNOWNCOMBINATOR FilterCombinator = 0
	FilterCombinator_AND               FilterCombinator = 1
	FilterCombinator_OR                FilterCombinator = 2
)

var FilterCombinator_name = map[int32]string{
	0: "UNKNOWNCOMBINATOR",
	1: "AND",
	2: "OR",
}
var FilterCombinator_value = map[string]int32{
	"UNKNOWNCOMBINATOR": 0,
	"AND":               1,
	"OR":                2,
}

func (x FilterCombinator) String() string {
	return proto.EnumName(FilterCombinator_name, int32(x))
}
func (FilterCombinator) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuery, []int{1} }

type SortOrder int32

const (
	SortOrder_UNKNOWNSORTORDER SortOrder = 0
	SortOrder_ASCENDING        SortOrder = 1
	SortOrder_DESCENDING       SortOrder = 2
)

var SortOrder_name = map[int32]string{
	0: "UNKNOWNSORTORDER",
	1: "ASCENDING",
	2: "DESCENDING",
}
var SortOrder_value = map[string]int32{
	"UNKNOWNSORTORDER": 0,
	"ASCENDING":        1,
	"DESCENDING":       2,
}

func (x SortOrder) String() string {
	return proto.EnumName(SortOrder_name, int32(x))
}
func (SortOrder) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuery, []int{2} }

type Filter_Op int32

const (
	Filter_UNKNOWNOP          Filter_Op = 0
	Filter_EQUALS             Filter_Op = 1
	Filter_NOTEQUALS          Filter_Op = 2
	Filter_LARGERTHAN         Filter_Op = 3
	Filter_LARGERTHANOREQUAL  Filter_Op = 4
	Filter_SMALLERTHAN        Filter_Op = 5
	Filter_SMALLERTHANOREQUAL Filter_Op = 6
	Filter_STARTSWITH         Filter_Op = 7
	Filter_DOESNOTSTARTWITH   Filter_Op = 8
	Filter_ENDSWITH           Filter_Op = 9
	Filter_DOESNOTENDWITH     Filter_Op = 10
	Filter_CONTAINS           Filter_Op = 11
	Filter_DOESNOTCONTAIN     Filter_Op = 12
	Filter_ISNULL             Filter_Op = 13
	Filter_ISNOTNULL          Filter_Op = 14
	Filter_EXISTS             Filter_Op = 15
	Filter_DOESNOTEXIST       Filter_Op = 16
)

var Filter_Op_name = map[int32]string{
	0:  "UNKNOWNOP",
	1:  "EQUALS",
	2:  "NOTEQUALS",
	3:  "LARGERTHAN",
	4:  "LARGERTHANOREQUAL",
	5:  "SMALLERTHAN",
	6:  "SMALLERTHANOREQUAL",
	7:  "STARTSWITH",
	8:  "DOESNOTSTARTWITH",
	9:  "ENDSWITH",
	10: "DOESNOTENDWITH",
	11: "CONTAINS",
	12: "DOESNOTCONTAIN",
	13: "ISNULL",
	14: "ISNOTNULL",
	15: "EXISTS",
	16: "DOESNOTEXIST",
}
var Filter_Op_value = map[string]int32{
	"UNKNOWNOP":          0,
	"EQUALS":             1,
	"NOTEQUALS":          2,
	"LARGERTHAN":         3,
	"LARGERTHANOREQUAL":  4,
	"SMALLERTHAN":        5,
	"SMALLERTHANOREQUAL": 6,
	"STARTSWITH":         7,
	"DOESNOTSTARTWITH":   8,
	"ENDSWITH":           9,
	"DOESNOTENDWITH":     10,
	"CONTAINS":           11,
	"DOESNOTCONTAIN":     12,
	"ISNULL":             13,
	"ISNOTNULL":          14,
	"EXISTS":             15,
	"DOESNOTEXIST":       16,
}

func (x Filter_Op) String() string {
	return proto.EnumName(Filter_Op_name, int32(x))
}
func (Filter_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuery, []int{4, 0} }

type Calculation_Op int32

const (
	Calculation_UNKNOWNOP Calculation_Op = 0
	Calculation_COUNT     Calculation_Op = 1
	Calculation_SUM       Calculation_Op = 2
	Calculation_AVG       Calculation_Op = 3
	Calculation_MIN       Calculation_Op = 4
	Calculation_MAX       Calculation_Op = 5
)

var Calculation_Op_name = map[int32]string{
	0: "UNKNOWNOP",
	1: "COUNT",
	2: "SUM",
	3: "AVG",
	4: "MIN",
	5: "MAX",
}
var Calculation_Op_value = map[string]int32{
	"UNKNOWNOP": 0,
	"COUNT":     1,
	"SUM":       2,
	"AVG":       3,
	"MIN":       4,
	"MAX":       5,
}

func (x Calculation_Op) String() string {
	return proto.EnumName(Calculation_Op_name, int32(x))
}
func (Calculation_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptorQuery, []int{5, 0} }

type RawQuery struct {
	Namespace        string           `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	StartTime        OptionalInt64    `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time"`
	EndTime          OptionalInt64    `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time"`
	TimeUnit         OptionalTimeUnit `protobuf:"bytes,4,opt,name=time_unit,json=timeUnit" json:"time_unit"`
	TimeRangeInNanos OptionalInt64    `protobuf:"bytes,5,opt,name=time_range_in_nanos,json=timeRangeInNanos" json:"time_range_in_nanos"`
	Filters          []FilterList     `protobuf:"bytes,6,rep,name=filters" json:"filters"`
	OrderBy          []OrderBy        `protobuf:"bytes,7,rep,name=order_by,json=orderBy" json:"order_by"`
	Limit            OptionalInt64    `protobuf:"bytes,8,opt,name=limit" json:"limit"`
}

func (m *RawQuery) Reset()                    { *m = RawQuery{} }
func (m *RawQuery) String() string            { return proto.CompactTextString(m) }
func (*RawQuery) ProtoMessage()               {}
func (*RawQuery) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{0} }

func (m *RawQuery) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *RawQuery) GetStartTime() OptionalInt64 {
	if m != nil {
		return m.StartTime
	}
	return OptionalInt64{}
}

func (m *RawQuery) GetEndTime() OptionalInt64 {
	if m != nil {
		return m.EndTime
	}
	return OptionalInt64{}
}

func (m *RawQuery) GetTimeUnit() OptionalTimeUnit {
	if m != nil {
		return m.TimeUnit
	}
	return OptionalTimeUnit{}
}

func (m *RawQuery) GetTimeRangeInNanos() OptionalInt64 {
	if m != nil {
		return m.TimeRangeInNanos
	}
	return OptionalInt64{}
}

func (m *RawQuery) GetFilters() []FilterList {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *RawQuery) GetOrderBy() []OrderBy {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *RawQuery) GetLimit() OptionalInt64 {
	if m != nil {
		return m.Limit
	}
	return OptionalInt64{}
}

type GroupedQuery struct {
	Namespace        string           `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	StartTime        OptionalInt64    `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time"`
	EndTime          OptionalInt64    `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time"`
	TimeUnit         OptionalTimeUnit `protobuf:"bytes,4,opt,name=time_unit,json=timeUnit" json:"time_unit"`
	TimeRangeInNanos OptionalInt64    `protobuf:"bytes,5,opt,name=time_range_in_nanos,json=timeRangeInNanos" json:"time_range_in_nanos"`
	Filters          []FilterList     `protobuf:"bytes,6,rep,name=filters" json:"filters"`
	GroupBy          []string         `protobuf:"bytes,7,rep,name=group_by,json=groupBy" json:"group_by,omitempty"`
	Calculations     []Calculation    `protobuf:"bytes,8,rep,name=calculations" json:"calculations"`
	OrderBy          []OrderBy        `protobuf:"bytes,9,rep,name=order_by,json=orderBy" json:"order_by"`
	Limit            OptionalInt64    `protobuf:"bytes,10,opt,name=limit" json:"limit"`
}

func (m *GroupedQuery) Reset()                    { *m = GroupedQuery{} }
func (m *GroupedQuery) String() string            { return proto.CompactTextString(m) }
func (*GroupedQuery) ProtoMessage()               {}
func (*GroupedQuery) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{1} }

func (m *GroupedQuery) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GroupedQuery) GetStartTime() OptionalInt64 {
	if m != nil {
		return m.StartTime
	}
	return OptionalInt64{}
}

func (m *GroupedQuery) GetEndTime() OptionalInt64 {
	if m != nil {
		return m.EndTime
	}
	return OptionalInt64{}
}

func (m *GroupedQuery) GetTimeUnit() OptionalTimeUnit {
	if m != nil {
		return m.TimeUnit
	}
	return OptionalTimeUnit{}
}

func (m *GroupedQuery) GetTimeRangeInNanos() OptionalInt64 {
	if m != nil {
		return m.TimeRangeInNanos
	}
	return OptionalInt64{}
}

func (m *GroupedQuery) GetFilters() []FilterList {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *GroupedQuery) GetGroupBy() []string {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *GroupedQuery) GetCalculations() []Calculation {
	if m != nil {
		return m.Calculations
	}
	return nil
}

func (m *GroupedQuery) GetOrderBy() []OrderBy {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *GroupedQuery) GetLimit() OptionalInt64 {
	if m != nil {
		return m.Limit
	}
	return OptionalInt64{}
}

type TimeBucketQuery struct {
	Namespace              string           `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	StartTime              OptionalInt64    `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time"`
	EndTime                OptionalInt64    `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time"`
	TimeUnit               OptionalTimeUnit `protobuf:"bytes,4,opt,name=time_unit,json=timeUnit" json:"time_unit"`
	TimeRangeInNanos       OptionalInt64    `protobuf:"bytes,5,opt,name=time_range_in_nanos,json=timeRangeInNanos" json:"time_range_in_nanos"`
	TimeGranularityInNanos int64            `protobuf:"varint,6,opt,name=time_granularity_in_nanos,json=timeGranularityInNanos,proto3" json:"time_granularity_in_nanos,omitempty"`
	Filters                []FilterList     `protobuf:"bytes,7,rep,name=filters" json:"filters"`
}

func (m *TimeBucketQuery) Reset()                    { *m = TimeBucketQuery{} }
func (m *TimeBucketQuery) String() string            { return proto.CompactTextString(m) }
func (*TimeBucketQuery) ProtoMessage()               {}
func (*TimeBucketQuery) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{2} }

func (m *TimeBucketQuery) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *TimeBucketQuery) GetStartTime() OptionalInt64 {
	if m != nil {
		return m.StartTime
	}
	return OptionalInt64{}
}

func (m *TimeBucketQuery) GetEndTime() OptionalInt64 {
	if m != nil {
		return m.EndTime
	}
	return OptionalInt64{}
}

func (m *TimeBucketQuery) GetTimeUnit() OptionalTimeUnit {
	if m != nil {
		return m.TimeUnit
	}
	return OptionalTimeUnit{}
}

func (m *TimeBucketQuery) GetTimeRangeInNanos() OptionalInt64 {
	if m != nil {
		return m.TimeRangeInNanos
	}
	return OptionalInt64{}
}

func (m *TimeBucketQuery) GetTimeGranularityInNanos() int64 {
	if m != nil {
		return m.TimeGranularityInNanos
	}
	return 0
}

func (m *TimeBucketQuery) GetFilters() []FilterList {
	if m != nil {
		return m.Filters
	}
	return nil
}

type FilterList struct {
	Filters          []Filter                 `protobuf:"bytes,1,rep,name=filters" json:"filters"`
	FilterCombinator OptionalFilterCombinator `protobuf:"bytes,2,opt,name=filter_combinator,json=filterCombinator" json:"filter_combinator"`
}

func (m *FilterList) Reset()                    { *m = FilterList{} }
func (m *FilterList) String() string            { return proto.CompactTextString(m) }
func (*FilterList) ProtoMessage()               {}
func (*FilterList) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{3} }

func (m *FilterList) GetFilters() []Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *FilterList) GetFilterCombinator() OptionalFilterCombinator {
	if m != nil {
		return m.FilterCombinator
	}
	return OptionalFilterCombinator{}
}

type Filter struct {
	Field string              `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Op    Filter_Op           `protobuf:"varint,2,opt,name=op,proto3,enum=servicepb.Filter_Op" json:"op,omitempty"`
	Value OptionalFilterValue `protobuf:"bytes,3,opt,name=value" json:"value"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{4} }

func (m *Filter) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Filter) GetOp() Filter_Op {
	if m != nil {
		return m.Op
	}
	return Filter_UNKNOWNOP
}

func (m *Filter) GetValue() OptionalFilterValue {
	if m != nil {
		return m.Value
	}
	return OptionalFilterValue{}
}

type Calculation struct {
	Field OptionalString `protobuf:"bytes,1,opt,name=field" json:"field"`
	Op    Calculation_Op `protobuf:"varint,2,opt,name=op,proto3,enum=servicepb.Calculation_Op" json:"op,omitempty"`
}

func (m *Calculation) Reset()                    { *m = Calculation{} }
func (m *Calculation) String() string            { return proto.CompactTextString(m) }
func (*Calculation) ProtoMessage()               {}
func (*Calculation) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{5} }

func (m *Calculation) GetField() OptionalString {
	if m != nil {
		return m.Field
	}
	return OptionalString{}
}

func (m *Calculation) GetOp() Calculation_Op {
	if m != nil {
		return m.Op
	}
	return Calculation_UNKNOWNOP
}

type OrderBy struct {
	Field OptionalString        `protobuf:"bytes,1,opt,name=field" json:"field"`
	Op    OptionalCalculationOp `protobuf:"bytes,2,opt,name=op" json:"op"`
	Order OptionalSortOrder     `protobuf:"bytes,3,opt,name=order" json:"order"`
}

func (m *OrderBy) Reset()                    { *m = OrderBy{} }
func (m *OrderBy) String() string            { return proto.CompactTextString(m) }
func (*OrderBy) ProtoMessage()               {}
func (*OrderBy) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{6} }

func (m *OrderBy) GetField() OptionalString {
	if m != nil {
		return m.Field
	}
	return OptionalString{}
}

func (m *OrderBy) GetOp() OptionalCalculationOp {
	if m != nil {
		return m.Op
	}
	return OptionalCalculationOp{}
}

func (m *OrderBy) GetOrder() OptionalSortOrder {
	if m != nil {
		return m.Order
	}
	return OptionalSortOrder{}
}

type OptionalTimeUnit struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalTimeUnit_NoValue
	//	*OptionalTimeUnit_Data
	Value isOptionalTimeUnit_Value `protobuf_oneof:"value"`
}

func (m *OptionalTimeUnit) Reset()                    { *m = OptionalTimeUnit{} }
func (m *OptionalTimeUnit) String() string            { return proto.CompactTextString(m) }
func (*OptionalTimeUnit) ProtoMessage()               {}
func (*OptionalTimeUnit) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{7} }

type isOptionalTimeUnit_Value interface {
	isOptionalTimeUnit_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalTimeUnit_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalTimeUnit_Data struct {
	Data TimeUnit `protobuf:"varint,2,opt,name=data,proto3,enum=servicepb.TimeUnit,oneof"`
}

func (*OptionalTimeUnit_NoValue) isOptionalTimeUnit_Value() {}
func (*OptionalTimeUnit_Data) isOptionalTimeUnit_Value()    {}

func (m *OptionalTimeUnit) GetValue() isOptionalTimeUnit_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalTimeUnit) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalTimeUnit_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalTimeUnit) GetData() TimeUnit {
	if x, ok := m.GetValue().(*OptionalTimeUnit_Data); ok {
		return x.Data
	}
	return TimeUnit_UNKNOWNUNIT
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalTimeUnit) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalTimeUnit_OneofMarshaler, _OptionalTimeUnit_OneofUnmarshaler, _OptionalTimeUnit_OneofSizer, []interface{}{
		(*OptionalTimeUnit_NoValue)(nil),
		(*OptionalTimeUnit_Data)(nil),
	}
}

func _OptionalTimeUnit_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalTimeUnit)
	// value
	switch x := m.Value.(type) {
	case *OptionalTimeUnit_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalTimeUnit_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Data))
	case nil:
	default:
		return fmt.Errorf("OptionalTimeUnit.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalTimeUnit_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalTimeUnit)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalTimeUnit_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalTimeUnit_Data{TimeUnit(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalTimeUnit_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalTimeUnit)
	// value
	switch x := m.Value.(type) {
	case *OptionalTimeUnit_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalTimeUnit_Data:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OptionalInt64 struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalInt64_NoValue
	//	*OptionalInt64_Data
	Value isOptionalInt64_Value `protobuf_oneof:"value"`
}

func (m *OptionalInt64) Reset()                    { *m = OptionalInt64{} }
func (m *OptionalInt64) String() string            { return proto.CompactTextString(m) }
func (*OptionalInt64) ProtoMessage()               {}
func (*OptionalInt64) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{8} }

type isOptionalInt64_Value interface {
	isOptionalInt64_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalInt64_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalInt64_Data struct {
	Data int64 `protobuf:"varint,2,opt,name=data,proto3,oneof"`
}

func (*OptionalInt64_NoValue) isOptionalInt64_Value() {}
func (*OptionalInt64_Data) isOptionalInt64_Value()    {}

func (m *OptionalInt64) GetValue() isOptionalInt64_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalInt64) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalInt64_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalInt64) GetData() int64 {
	if x, ok := m.GetValue().(*OptionalInt64_Data); ok {
		return x.Data
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalInt64) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalInt64_OneofMarshaler, _OptionalInt64_OneofUnmarshaler, _OptionalInt64_OneofSizer, []interface{}{
		(*OptionalInt64_NoValue)(nil),
		(*OptionalInt64_Data)(nil),
	}
}

func _OptionalInt64_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalInt64)
	// value
	switch x := m.Value.(type) {
	case *OptionalInt64_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalInt64_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Data))
	case nil:
	default:
		return fmt.Errorf("OptionalInt64.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalInt64_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalInt64)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalInt64_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalInt64_Data{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalInt64_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalInt64)
	// value
	switch x := m.Value.(type) {
	case *OptionalInt64_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalInt64_Data:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OptionalFilterCombinator struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalFilterCombinator_NoValue
	//	*OptionalFilterCombinator_Data
	Value isOptionalFilterCombinator_Value `protobuf_oneof:"value"`
}

func (m *OptionalFilterCombinator) Reset()                    { *m = OptionalFilterCombinator{} }
func (m *OptionalFilterCombinator) String() string            { return proto.CompactTextString(m) }
func (*OptionalFilterCombinator) ProtoMessage()               {}
func (*OptionalFilterCombinator) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{9} }

type isOptionalFilterCombinator_Value interface {
	isOptionalFilterCombinator_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalFilterCombinator_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalFilterCombinator_Data struct {
	Data FilterCombinator `protobuf:"varint,2,opt,name=data,proto3,enum=servicepb.FilterCombinator,oneof"`
}

func (*OptionalFilterCombinator_NoValue) isOptionalFilterCombinator_Value() {}
func (*OptionalFilterCombinator_Data) isOptionalFilterCombinator_Value()    {}

func (m *OptionalFilterCombinator) GetValue() isOptionalFilterCombinator_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalFilterCombinator) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalFilterCombinator_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalFilterCombinator) GetData() FilterCombinator {
	if x, ok := m.GetValue().(*OptionalFilterCombinator_Data); ok {
		return x.Data
	}
	return FilterCombinator_UNKNOWNCOMBINATOR
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalFilterCombinator) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalFilterCombinator_OneofMarshaler, _OptionalFilterCombinator_OneofUnmarshaler, _OptionalFilterCombinator_OneofSizer, []interface{}{
		(*OptionalFilterCombinator_NoValue)(nil),
		(*OptionalFilterCombinator_Data)(nil),
	}
}

func _OptionalFilterCombinator_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalFilterCombinator)
	// value
	switch x := m.Value.(type) {
	case *OptionalFilterCombinator_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalFilterCombinator_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Data))
	case nil:
	default:
		return fmt.Errorf("OptionalFilterCombinator.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalFilterCombinator_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalFilterCombinator)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalFilterCombinator_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalFilterCombinator_Data{FilterCombinator(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalFilterCombinator_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalFilterCombinator)
	// value
	switch x := m.Value.(type) {
	case *OptionalFilterCombinator_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalFilterCombinator_Data:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OptionalString struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalString_NoValue
	//	*OptionalString_Data
	Value isOptionalString_Value `protobuf_oneof:"value"`
}

func (m *OptionalString) Reset()                    { *m = OptionalString{} }
func (m *OptionalString) String() string            { return proto.CompactTextString(m) }
func (*OptionalString) ProtoMessage()               {}
func (*OptionalString) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{10} }

type isOptionalString_Value interface {
	isOptionalString_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalString_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalString_Data struct {
	Data string `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*OptionalString_NoValue) isOptionalString_Value() {}
func (*OptionalString_Data) isOptionalString_Value()    {}

func (m *OptionalString) GetValue() isOptionalString_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalString) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalString_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalString) GetData() string {
	if x, ok := m.GetValue().(*OptionalString_Data); ok {
		return x.Data
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalString) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalString_OneofMarshaler, _OptionalString_OneofUnmarshaler, _OptionalString_OneofSizer, []interface{}{
		(*OptionalString_NoValue)(nil),
		(*OptionalString_Data)(nil),
	}
}

func _OptionalString_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalString)
	// value
	switch x := m.Value.(type) {
	case *OptionalString_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalString_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("OptionalString.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalString_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalString)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalString_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &OptionalString_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalString_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalString)
	// value
	switch x := m.Value.(type) {
	case *OptionalString_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalString_Data:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OptionalCalculationOp struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalCalculationOp_NoValue
	//	*OptionalCalculationOp_Data
	Value isOptionalCalculationOp_Value `protobuf_oneof:"value"`
}

func (m *OptionalCalculationOp) Reset()                    { *m = OptionalCalculationOp{} }
func (m *OptionalCalculationOp) String() string            { return proto.CompactTextString(m) }
func (*OptionalCalculationOp) ProtoMessage()               {}
func (*OptionalCalculationOp) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{11} }

type isOptionalCalculationOp_Value interface {
	isOptionalCalculationOp_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalCalculationOp_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalCalculationOp_Data struct {
	Data Calculation_Op `protobuf:"varint,2,opt,name=data,proto3,enum=servicepb.Calculation_Op,oneof"`
}

func (*OptionalCalculationOp_NoValue) isOptionalCalculationOp_Value() {}
func (*OptionalCalculationOp_Data) isOptionalCalculationOp_Value()    {}

func (m *OptionalCalculationOp) GetValue() isOptionalCalculationOp_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalCalculationOp) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalCalculationOp_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalCalculationOp) GetData() Calculation_Op {
	if x, ok := m.GetValue().(*OptionalCalculationOp_Data); ok {
		return x.Data
	}
	return Calculation_UNKNOWNOP
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalCalculationOp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalCalculationOp_OneofMarshaler, _OptionalCalculationOp_OneofUnmarshaler, _OptionalCalculationOp_OneofSizer, []interface{}{
		(*OptionalCalculationOp_NoValue)(nil),
		(*OptionalCalculationOp_Data)(nil),
	}
}

func _OptionalCalculationOp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalCalculationOp)
	// value
	switch x := m.Value.(type) {
	case *OptionalCalculationOp_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalCalculationOp_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Data))
	case nil:
	default:
		return fmt.Errorf("OptionalCalculationOp.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalCalculationOp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalCalculationOp)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalCalculationOp_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalCalculationOp_Data{Calculation_Op(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalCalculationOp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalCalculationOp)
	// value
	switch x := m.Value.(type) {
	case *OptionalCalculationOp_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalCalculationOp_Data:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type OptionalSortOrder struct {
	// Types that are valid to be assigned to Value:
	//	*OptionalSortOrder_NoValue
	//	*OptionalSortOrder_Data
	Value isOptionalSortOrder_Value `protobuf_oneof:"value"`
}

func (m *OptionalSortOrder) Reset()                    { *m = OptionalSortOrder{} }
func (m *OptionalSortOrder) String() string            { return proto.CompactTextString(m) }
func (*OptionalSortOrder) ProtoMessage()               {}
func (*OptionalSortOrder) Descriptor() ([]byte, []int) { return fileDescriptorQuery, []int{12} }

type isOptionalSortOrder_Value interface {
	isOptionalSortOrder_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptionalSortOrder_NoValue struct {
	NoValue bool `protobuf:"varint,1,opt,name=no_value,json=noValue,proto3,oneof"`
}
type OptionalSortOrder_Data struct {
	Data SortOrder `protobuf:"varint,2,opt,name=data,proto3,enum=servicepb.SortOrder,oneof"`
}

func (*OptionalSortOrder_NoValue) isOptionalSortOrder_Value() {}
func (*OptionalSortOrder_Data) isOptionalSortOrder_Value()    {}

func (m *OptionalSortOrder) GetValue() isOptionalSortOrder_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionalSortOrder) GetNoValue() bool {
	if x, ok := m.GetValue().(*OptionalSortOrder_NoValue); ok {
		return x.NoValue
	}
	return false
}

func (m *OptionalSortOrder) GetData() SortOrder {
	if x, ok := m.GetValue().(*OptionalSortOrder_Data); ok {
		return x.Data
	}
	return SortOrder_UNKNOWNSORTORDER
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionalSortOrder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OptionalSortOrder_OneofMarshaler, _OptionalSortOrder_OneofUnmarshaler, _OptionalSortOrder_OneofSizer, []interface{}{
		(*OptionalSortOrder_NoValue)(nil),
		(*OptionalSortOrder_Data)(nil),
	}
}

func _OptionalSortOrder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionalSortOrder)
	// value
	switch x := m.Value.(type) {
	case *OptionalSortOrder_NoValue:
		t := uint64(0)
		if x.NoValue {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionalSortOrder_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Data))
	case nil:
	default:
		return fmt.Errorf("OptionalSortOrder.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionalSortOrder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionalSortOrder)
	switch tag {
	case 1: // value.no_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalSortOrder_NoValue{x != 0}
		return true, err
	case 2: // value.data
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionalSortOrder_Data{SortOrder(x)}
		return true, err
	default:
		return false, nil
	}
}

func _OptionalSortOrder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OptionalSortOrder)
	// value
	switch x := m.Value.(type) {
	case *OptionalSortOrder_NoValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *OptionalSortOrder_Data:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Data))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*RawQuery)(nil), "servicepb.RawQuery")
	proto.RegisterType((*GroupedQuery)(nil), "servicepb.GroupedQuery")
	proto.RegisterType((*TimeBucketQuery)(nil), "servicepb.TimeBucketQuery")
	proto.RegisterType((*FilterList)(nil), "servicepb.FilterList")
	proto.RegisterType((*Filter)(nil), "servicepb.Filter")
	proto.RegisterType((*Calculation)(nil), "servicepb.Calculation")
	proto.RegisterType((*OrderBy)(nil), "servicepb.OrderBy")
	proto.RegisterType((*OptionalTimeUnit)(nil), "servicepb.OptionalTimeUnit")
	proto.RegisterType((*OptionalInt64)(nil), "servicepb.OptionalInt64")
	proto.RegisterType((*OptionalFilterCombinator)(nil), "servicepb.OptionalFilterCombinator")
	proto.RegisterType((*OptionalString)(nil), "servicepb.OptionalString")
	proto.RegisterType((*OptionalCalculationOp)(nil), "servicepb.OptionalCalculationOp")
	proto.RegisterType((*OptionalSortOrder)(nil), "servicepb.OptionalSortOrder")
	proto.RegisterEnum("servicepb.TimeUnit", TimeUnit_name, TimeUnit_value)
	proto.RegisterEnum("servicepb.FilterCombinator", FilterCombinator_name, FilterCombinator_value)
	proto.RegisterEnum("servicepb.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterEnum("servicepb.Filter_Op", Filter_Op_name, Filter_Op_value)
	proto.RegisterEnum("servicepb.Calculation_Op", Calculation_Op_name, Calculation_Op_value)
}
func (m *RawQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.StartTime.Size()))
	n1, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x1a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.EndTime.Size()))
	n2, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x22
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeUnit.Size()))
	n3, err := m.TimeUnit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x2a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeRangeInNanos.Size()))
	n4, err := m.TimeRangeInNanos.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x32
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Limit.Size()))
	n5, err := m.Limit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *GroupedQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupedQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.StartTime.Size()))
	n6, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.EndTime.Size()))
	n7, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeUnit.Size()))
	n8, err := m.TimeUnit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x2a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeRangeInNanos.Size()))
	n9, err := m.TimeRangeInNanos.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x32
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Calculations) > 0 {
		for _, msg := range m.Calculations {
			dAtA[i] = 0x42
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Limit.Size()))
	n10, err := m.Limit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *TimeBucketQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeBucketQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.StartTime.Size()))
	n11, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.EndTime.Size()))
	n12, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x22
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeUnit.Size()))
	n13, err := m.TimeUnit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x2a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.TimeRangeInNanos.Size()))
	n14, err := m.TimeRangeInNanos.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.TimeGranularityInNanos != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintQuery(dAtA, i, uint64(m.TimeGranularityInNanos))
	}
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.FilterCombinator.Size()))
	n15, err := m.FilterCombinator.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	return i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Field) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Field)))
		i += copy(dAtA[i:], m.Field)
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuery(dAtA, i, uint64(m.Op))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Value.Size()))
	n16, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *Calculation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Calculation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Field.Size()))
	n17, err := m.Field.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQuery(dAtA, i, uint64(m.Op))
	}
	return i, nil
}

func (m *OrderBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Field.Size()))
	n18, err := m.Field.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Op.Size()))
	n19, err := m.Op.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x1a
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Order.Size()))
	n20, err := m.Order.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *OptionalTimeUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalTimeUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn21, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	return i, nil
}

func (m *OptionalTimeUnit_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalTimeUnit_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Data))
	return i, nil
}
func (m *OptionalInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalInt64) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn22, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *OptionalInt64_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalInt64_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Data))
	return i, nil
}
func (m *OptionalFilterCombinator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalFilterCombinator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn23, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	return i, nil
}

func (m *OptionalFilterCombinator_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalFilterCombinator_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Data))
	return i, nil
}
func (m *OptionalString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn24, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	return i, nil
}

func (m *OptionalString_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalString_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintQuery(dAtA, i, uint64(len(m.Data)))
	i += copy(dAtA[i:], m.Data)
	return i, nil
}
func (m *OptionalCalculationOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalCalculationOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn25, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn25
	}
	return i, nil
}

func (m *OptionalCalculationOp_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalCalculationOp_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Data))
	return i, nil
}
func (m *OptionalSortOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionalSortOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn26, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	return i, nil
}

func (m *OptionalSortOrder_NoValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.NoValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *OptionalSortOrder_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintQuery(dAtA, i, uint64(m.Data))
	return i, nil
}
func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RawQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.StartTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeUnit.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeRangeInNanos.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = m.Limit.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *GroupedQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.StartTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeUnit.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeRangeInNanos.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Calculations) > 0 {
		for _, e := range m.Calculations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = m.Limit.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *TimeBucketQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.StartTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeUnit.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.TimeRangeInNanos.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.TimeGranularityInNanos != 0 {
		n += 1 + sovQuery(uint64(m.TimeGranularityInNanos))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *FilterList) Size() (n int) {
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = m.FilterCombinator.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *Filter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovQuery(uint64(m.Op))
	}
	l = m.Value.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *Calculation) Size() (n int) {
	var l int
	_ = l
	l = m.Field.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.Op != 0 {
		n += 1 + sovQuery(uint64(m.Op))
	}
	return n
}

func (m *OrderBy) Size() (n int) {
	var l int
	_ = l
	l = m.Field.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Op.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Order.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *OptionalTimeUnit) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalTimeUnit_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalTimeUnit_Data) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQuery(uint64(m.Data))
	return n
}
func (m *OptionalInt64) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalInt64_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalInt64_Data) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQuery(uint64(m.Data))
	return n
}
func (m *OptionalFilterCombinator) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalFilterCombinator_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalFilterCombinator_Data) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQuery(uint64(m.Data))
	return n
}
func (m *OptionalString) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalString_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalString_Data) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	n += 1 + l + sovQuery(uint64(l))
	return n
}
func (m *OptionalCalculationOp) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalCalculationOp_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalCalculationOp_Data) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQuery(uint64(m.Data))
	return n
}
func (m *OptionalSortOrder) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *OptionalSortOrder_NoValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptionalSortOrder_Data) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovQuery(uint64(m.Data))
	return n
}

func sovQuery(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeUnit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRangeInNanos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeRangeInNanos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, FilterList{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, OrderBy{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupedQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupedQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupedQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeUnit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRangeInNanos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeRangeInNanos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, FilterList{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calculations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calculations = append(m.Calculations, Calculation{})
			if err := m.Calculations[len(m.Calculations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, OrderBy{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeBucketQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeBucketQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeBucketQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeUnit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRangeInNanos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeRangeInNanos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeGranularityInNanos", wireType)
			}
			m.TimeGranularityInNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeGranularityInNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, FilterList{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterCombinator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FilterCombinator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Filter_Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Calculation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Calculation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Calculation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Calculation_Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Op.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalTimeUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalTimeUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalTimeUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalTimeUnit_NoValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v TimeUnit
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TimeUnit(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &OptionalTimeUnit_Data{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalInt64_NoValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &OptionalInt64_Data{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalFilterCombinator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalFilterCombinator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalFilterCombinator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalFilterCombinator_NoValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v FilterCombinator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (FilterCombinator(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &OptionalFilterCombinator_Data{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalString_NoValue{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &OptionalString_Data{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalCalculationOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalCalculationOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalCalculationOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalCalculationOp_NoValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v Calculation_Op
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Calculation_Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &OptionalCalculationOp_Data{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionalSortOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionalSortOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionalSortOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &OptionalSortOrder_NoValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v SortOrder
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (SortOrder(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &OptionalSortOrder_Data{v}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQuery(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQuery = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/xichen2020/eventdb/generated/proto/servicepb/query.proto", fileDescriptorQuery)
}

var fileDescriptorQuery = []byte{
	// 1159 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0xf5, 0x49, 0x8e, 0xfc, 0xb1, 0xde, 0xd8, 0x86, 0x1c, 0x07, 0x7e, 0x0d, 0xbd, 0x3d,
	0x38, 0x06, 0x6a, 0x25, 0xca, 0x47, 0x9b, 0x00, 0x2d, 0x42, 0x7d, 0xd4, 0x26, 0x22, 0x2d, 0x1b,
	0x92, 0x72, 0x92, 0x5e, 0x04, 0x4a, 0x5a, 0x2b, 0x44, 0x25, 0x52, 0xa5, 0x28, 0xb7, 0xbe, 0xf6,
	0x17, 0xf4, 0xd6, 0x73, 0x81, 0x9e, 0x7a, 0x6c, 0xfb, 0x23, 0x72, 0x2c, 0xd0, 0x7b, 0x51, 0xb8,
	0x7f, 0xa4, 0xd8, 0xe5, 0x4a, 0xa2, 0x2c, 0xd9, 0xb0, 0x0d, 0xf4, 0x96, 0xdb, 0xce, 0xec, 0x3c,
	0xcf, 0x0c, 0x67, 0x9e, 0x1d, 0x41, 0x50, 0xee, 0x3a, 0xc1, 0xbb, 0x51, 0xeb, 0xa0, 0xed, 0xf5,
	0x0b, 0xdf, 0x39, 0xed, 0x77, 0xd4, 0x2d, 0x3e, 0x28, 0x3e, 0x28, 0xd0, 0x53, 0xea, 0x06, 0x9d,
	0x56, 0xa1, 0x4b, 0x5d, 0xea, 0xdb, 0x01, 0xed, 0x14, 0x06, 0xbe, 0x17, 0x78, 0x85, 0x21, 0xf5,
	0x4f, 0x9d, 0x36, 0x1d, 0xb4, 0x0a, 0xdf, 0x8c, 0xa8, 0x7f, 0x76, 0xc0, 0xbd, 0x58, 0x99, 0xb8,
	0xef, 0x7e, 0x1c, 0xe1, 0xeb, 0x7a, 0x5d, 0x2f, 0xc4, 0xb5, 0x46, 0x27, 0xdc, 0x0a, 0x49, 0xd8,
	0x29, 0x44, 0xde, 0xbd, 0x75, 0xfa, 0x53, 0xbb, 0x37, 0xa2, 0x21, 0x49, 0xfe, 0xcf, 0x04, 0xc8,
	0x86, 0xfd, 0xed, 0x2b, 0x56, 0x11, 0xbe, 0x07, 0x8a, 0x6b, 0xf7, 0xe9, 0x70, 0x60, 0xb7, 0x69,
	0x4e, 0xda, 0x95, 0xf6, 0x14, 0x63, 0xea, 0xc0, 0x9f, 0x01, 0x0c, 0x03, 0xdb, 0x0f, 0x9a, 0x81,
	0xd3, 0xa7, 0xb9, 0xf8, 0xae, 0xb4, 0x97, 0x2d, 0xe6, 0x0e, 0x26, 0xb4, 0x07, 0xfa, 0x20, 0x70,
	0x3c, 0xd7, 0xee, 0x69, 0x6e, 0xf0, 0xf4, 0x71, 0x29, 0xf9, 0xfe, 0xaf, 0xff, 0xc5, 0x0c, 0x85,
	0x23, 0x2c, 0xa7, 0x4f, 0xf1, 0x33, 0x90, 0xa9, 0xdb, 0x09, 0xc1, 0x89, 0x6b, 0x81, 0x33, 0xd4,
	0xed, 0x70, 0xe8, 0xe7, 0xa0, 0x30, 0x58, 0x73, 0xe4, 0x3a, 0x41, 0x2e, 0xc9, 0xb1, 0xdb, 0x0b,
	0xb0, 0x2c, 0xb6, 0xe1, 0x3a, 0x81, 0x80, 0xcb, 0x81, 0xb0, 0x71, 0x1d, 0xee, 0x70, 0xbc, 0x6f,
	0xbb, 0x5d, 0xda, 0x74, 0xdc, 0xa6, 0x6b, 0xbb, 0xde, 0x30, 0x97, 0xba, 0x56, 0x15, 0x88, 0x41,
	0x0d, 0x86, 0xd4, 0x5c, 0xc2, 0x70, 0xf8, 0x09, 0x64, 0x4e, 0x9c, 0x5e, 0x40, 0xfd, 0x61, 0x2e,
	0xbd, 0x9b, 0xd8, 0xcb, 0x16, 0x37, 0x22, 0x14, 0x5f, 0xf0, 0x9b, 0x9a, 0x33, 0x1c, 0x97, 0x31,
	0x8e, 0xc5, 0x8f, 0x40, 0xf6, 0xfc, 0x0e, 0xf5, 0x9b, 0xad, 0xb3, 0x5c, 0x86, 0xe3, 0x70, 0x34,
	0x35, 0xbb, 0x2a, 0x9d, 0x8d, 0x41, 0x5e, 0x68, 0xe2, 0xc7, 0x90, 0xea, 0x39, 0x7d, 0x27, 0xc8,
	0xc9, 0xd7, 0x2a, 0x36, 0x0c, 0xce, 0xff, 0x9e, 0x84, 0xa5, 0x43, 0xdf, 0x1b, 0x0d, 0x68, 0xe7,
	0xc3, 0x64, 0xff, 0xfb, 0xc9, 0x6e, 0x81, 0xdc, 0x65, 0xdd, 0x1e, 0x4f, 0x56, 0x31, 0x32, 0xdc,
	0x2e, 0x9d, 0xe1, 0x17, 0xb0, 0xd4, 0xb6, 0x7b, 0xed, 0x51, 0xcf, 0x66, 0xf9, 0x87, 0x39, 0x99,
	0xd3, 0x6e, 0x46, 0x68, 0xcb, 0xd3, 0x6b, 0xc1, 0x3b, 0x83, 0x98, 0x91, 0x8d, 0x72, 0x63, 0xd9,
	0xc0, 0x4d, 0x64, 0xf3, 0x4b, 0x02, 0x56, 0x59, 0xab, 0x4b, 0xa3, 0xf6, 0xd7, 0x34, 0xf8, 0xa0,
	0x9c, 0x1b, 0x28, 0xe7, 0x19, 0x6c, 0x71, 0xba, 0xae, 0x6f, 0xbb, 0xa3, 0x9e, 0xed, 0x3b, 0xc1,
	0xd9, 0x94, 0x34, 0xbd, 0x2b, 0xed, 0x25, 0x8c, 0x4d, 0x16, 0x70, 0x38, 0xbd, 0x5f, 0x20, 0xba,
	0xcc, 0xf5, 0x45, 0x97, 0xff, 0x51, 0x02, 0x98, 0xde, 0xe2, 0x87, 0x53, 0x16, 0x89, 0xb3, 0xac,
	0xcd, 0xb1, 0x5c, 0x94, 0xed, 0x31, 0xac, 0x85, 0xc7, 0x66, 0xdb, 0xeb, 0xb7, 0x1c, 0xd7, 0x0e,
	0x3c, 0x5f, 0xcc, 0xf0, 0xff, 0x0b, 0x1a, 0x10, 0x92, 0x94, 0x27, 0xa1, 0xe3, 0x5e, 0x9c, 0x5c,
	0xf0, 0xe7, 0x7f, 0x4e, 0x40, 0x3a, 0x0c, 0xc6, 0xeb, 0x90, 0x3a, 0x71, 0x68, 0xaf, 0x23, 0x94,
	0x13, 0x1a, 0xf8, 0x23, 0x88, 0x7b, 0x03, 0x9e, 0x69, 0xa5, 0xb8, 0x3e, 0x57, 0xe6, 0x81, 0x3e,
	0x30, 0xe2, 0xde, 0x00, 0x3f, 0x87, 0x14, 0xff, 0xa5, 0x12, 0xca, 0xd8, 0xb9, 0xb4, 0xa4, 0x63,
	0x16, 0x35, 0x56, 0x32, 0x87, 0xe4, 0x7f, 0x8a, 0x43, 0x5c, 0x1f, 0xe0, 0x65, 0x50, 0x1a, 0xe4,
	0x25, 0xd1, 0x5f, 0x13, 0xfd, 0x4b, 0x14, 0xc3, 0x00, 0xe9, 0xea, 0xab, 0x86, 0x5a, 0x33, 0x91,
	0xc4, 0xae, 0x88, 0x6e, 0x09, 0x33, 0x8e, 0x57, 0x00, 0x6a, 0xaa, 0x71, 0x58, 0x35, 0xac, 0x23,
	0x95, 0xa0, 0x04, 0xde, 0x80, 0xb5, 0xa9, 0xad, 0x1b, 0x3c, 0x0e, 0x25, 0xf1, 0x2a, 0x64, 0xcd,
	0xba, 0x5a, 0xab, 0x89, 0xb8, 0x14, 0xde, 0x04, 0x1c, 0x71, 0x8c, 0x03, 0xd3, 0x8c, 0xcf, 0xb4,
	0x54, 0xc3, 0x32, 0x5f, 0x6b, 0xd6, 0x11, 0xca, 0xe0, 0x75, 0x40, 0x15, 0xbd, 0x6a, 0x12, 0xdd,
	0xe2, 0x6e, 0xee, 0x95, 0xf1, 0x12, 0xc8, 0x55, 0x52, 0x09, 0x63, 0x14, 0x8c, 0x61, 0x45, 0xc4,
	0x54, 0x49, 0x85, 0xfb, 0x80, 0x45, 0x94, 0x75, 0x62, 0xa9, 0x1a, 0x31, 0x51, 0x36, 0x12, 0x21,
	0x9c, 0x68, 0x89, 0x7d, 0x94, 0x66, 0x92, 0x46, 0xad, 0x86, 0x96, 0xd9, 0x47, 0x69, 0xec, 0x96,
	0x9b, 0x2b, 0xfc, 0x7b, 0xdf, 0x68, 0xa6, 0x65, 0xa2, 0x55, 0x8c, 0x60, 0x69, 0x4c, 0xce, 0x5c,
	0x08, 0xe5, 0x7f, 0x93, 0x20, 0x1b, 0x59, 0x3e, 0xf8, 0x49, 0x74, 0x56, 0xd9, 0xe2, 0xd6, 0x82,
	0x7e, 0x9b, 0x81, 0xef, 0xb8, 0xdd, 0x71, 0xab, 0xc3, 0x61, 0xde, 0x8f, 0x0c, 0x73, 0x6b, 0xf1,
	0x5e, 0x13, 0x13, 0xcd, 0x97, 0x16, 0x0d, 0x45, 0x81, 0x54, 0x59, 0x6f, 0x10, 0x0b, 0x49, 0x38,
	0x03, 0x09, 0xb3, 0x51, 0x47, 0x71, 0x76, 0x50, 0x8f, 0x0f, 0x51, 0x82, 0x1d, 0xea, 0x1a, 0x41,
	0x49, 0x7e, 0x50, 0xdf, 0xa0, 0x54, 0xfe, 0x57, 0x09, 0x32, 0x62, 0xe9, 0xdd, 0xb6, 0xe2, 0xa7,
	0x93, 0x8a, 0xb3, 0xc5, 0xdd, 0x05, 0x98, 0x48, 0xe5, 0xfa, 0x40, 0x40, 0x99, 0x20, 0x3f, 0x85,
	0x14, 0xdf, 0xaf, 0x42, 0x90, 0xf7, 0x16, 0xa5, 0xf3, 0xfc, 0x20, 0xac, 0x4e, 0x64, 0xe4, 0x80,
	0x7c, 0x1b, 0xd0, 0xc5, 0x85, 0x84, 0xb7, 0x41, 0x76, 0xbd, 0x66, 0xa8, 0x70, 0x56, 0xbf, 0x7c,
	0x14, 0x33, 0x32, 0xae, 0xc7, 0xc5, 0x8c, 0xef, 0x43, 0xb2, 0x63, 0x07, 0xb6, 0x68, 0xeb, 0x9d,
	0x48, 0xa6, 0x31, 0xfe, 0x28, 0x66, 0xf0, 0x90, 0x52, 0x46, 0x3c, 0x93, 0xfc, 0x4b, 0x58, 0x9e,
	0xd9, 0x55, 0x57, 0x67, 0x58, 0x8f, 0x64, 0x48, 0xcc, 0x93, 0x0d, 0x21, 0x77, 0xd9, 0xbb, 0xbf,
	0x9a, 0xf7, 0xe1, 0x4c, 0xe5, 0xdb, 0x73, 0xaf, 0x7b, 0xca, 0x33, 0x9f, 0xb4, 0x06, 0x2b, 0xb3,
	0x73, 0xbb, 0xfe, 0x27, 0x28, 0xf3, 0x6c, 0x2e, 0x6c, 0x2c, 0x9c, 0xe8, 0xd5, 0xa4, 0x85, 0x99,
	0xfa, 0x2f, 0x17, 0xf4, 0x7c, 0x3e, 0x0a, 0x6b, 0x73, 0x32, 0xb8, 0x3a, 0xd7, 0xfe, 0x4c, 0xae,
	0xe8, 0x26, 0x9c, 0x10, 0xcc, 0xa5, 0xd9, 0xff, 0x5e, 0x02, 0x79, 0x22, 0xa2, 0x55, 0xc8, 0x8a,
	0xb7, 0xd4, 0x20, 0x9a, 0x15, 0xae, 0x38, 0xb3, 0x5a, 0xd6, 0x49, 0x05, 0x49, 0xec, 0xb2, 0xae,
	0xd5, 0x6a, 0x9a, 0x70, 0xc4, 0x43, 0x47, 0xd9, 0xd0, 0x85, 0x23, 0xc1, 0xb6, 0x14, 0x51, 0xc9,
	0xd8, 0x4e, 0x32, 0x74, 0x5d, 0x23, 0x0d, 0xab, 0x8a, 0x52, 0x58, 0x86, 0xe4, 0x91, 0xde, 0x30,
	0x50, 0x9a, 0xbd, 0xbd, 0x8a, 0xfa, 0x16, 0x65, 0x98, 0xeb, 0x6d, 0x55, 0x35, 0x90, 0xbc, 0xff,
	0x1c, 0xd0, 0x9c, 0x2c, 0x36, 0x60, 0x4d, 0xd4, 0x52, 0xd6, 0xeb, 0x25, 0x8d, 0xa8, 0x96, 0x6e,
	0xa0, 0x18, 0x7f, 0xcb, 0xbc, 0x9c, 0x34, 0xc4, 0x75, 0x03, 0xc5, 0xf7, 0x5f, 0x80, 0x32, 0xed,
	0xcf, 0x3a, 0x20, 0x01, 0x32, 0x75, 0xc3, 0xd2, 0x8d, 0x4a, 0x95, 0x61, 0x96, 0x41, 0x51, 0xcd,
	0x72, 0x95, 0x54, 0x34, 0x72, 0x88, 0x24, 0x56, 0x66, 0xa5, 0x3a, 0xb1, 0xe3, 0x25, 0xed, 0xfd,
	0xf9, 0x8e, 0xf4, 0xc7, 0xf9, 0x8e, 0xf4, 0xf7, 0xf9, 0x8e, 0xf4, 0xc3, 0x3f, 0x3b, 0xb1, 0xaf,
	0x3e, 0xb9, 0xe5, 0x7f, 0xa1, 0x56, 0x9a, 0x3b, 0x1e, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x78,
	0xa0, 0x86, 0x12, 0xcc, 0x0d, 0x00, 0x00,
}
